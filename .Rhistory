h5(title),
HTML(format_artfakta_info(html))
)
})
# Name-Image Matching Game Logic
rv_name_matching <- reactiveValues(
birds = NULL,
selected_name = NULL,
selected_image = NULL,
selected_bird = NULL,
matches = 0,
total = 0,
matched_ids = character(0),
order_images = NULL,
order_names = NULL
)
# Initialize name-image matching game
observeEvent(input$start_name_matching, {
# Select random birds
n_birds <- 6  # Number of birds to match
available_birds <- game_birds
selected_indices <- sample(nrow(available_birds), min(n_birds, nrow(available_birds)))
rv_name_matching$birds <- available_birds[selected_indices, ]
rv_name_matching$matches <- 0
rv_name_matching$total <- length(selected_indices)
rv_name_matching$selected_name <- NULL
rv_name_matching$selected_image <- NULL
rv_name_matching$selected_bird <- NULL
rv_name_matching$matched_ids <- character(0)
# Freeze list and grid order so images don't move on match
rv_name_matching$order_images <- sample(seq_len(nrow(rv_name_matching$birds)))
rv_name_matching$order_names  <- sample(seq_len(nrow(rv_name_matching$birds)))
})
# Render bird names list
output$name_matching_list <- renderUI({
cat("\n>>> RE-RENDERING name_matching_list at", as.character(Sys.time()), "\n")
birds_df <- req(rv_name_matching$birds)
if (is.null(rv_name_matching$order_names)) {
rv_name_matching$order_names <- seq_len(nrow(birds_df))
}
names_order <- rv_name_matching$order_names
div(class = "list-group",
lapply(names_order, function(i) {
id <- birds_df$taxonID[i]
actionButton(
inputId = paste0("name_", id),
label = birds_df$scientificName[i],
class = "list-group-item list-group-item-action text-start"
)
})
)
}) %>% bindEvent(rv_name_matching$birds, ignoreNULL = TRUE, ignoreInit = FALSE)
# Render bird images grid
output$image_matching_grid <- renderUI({
cat("\n>>> RE-RENDERING image_matching_grid at", as.character(Sys.time()), "\n")
birds_df <- req(rv_name_matching$birds)
if (is.null(rv_name_matching$order_images)) {
rv_name_matching$order_images <- seq_len(nrow(birds_df))
}
images_order <- rv_name_matching$order_images
div(class = "row",
lapply(images_order, function(i) {
id <- birds_df$taxonID[i]
# Don't check matched_ids here to avoid re-render on match
div(class = "col-md-4 mb-3 position-relative",
id = paste0("name_image_container_", id),
actionButton(
inputId = paste0("image_", id),
label = tags$img(
src = paste0(id, ".jpg"),
class = "square-img",
style = "max-width: 300px; max-height: 300px;"
),
class = "btn p-0"
)
)
})
)
}) %>% bindEvent(rv_name_matching$birds, ignoreNULL = TRUE, ignoreInit = FALSE)
# Play button for matched images in Name Matching (bottom-left overlay)
observe({
req(rv_name_matching$birds)
birds_df <- rv_name_matching$birds
lapply(birds_df$taxonID, function(id) {
observeEvent(input[[paste0("name_play_matched_sound_", id)]], {
sound_url <- get_sound_url(id)
if (!is.null(sound_url)) {
runjs(sprintf(
"var audio = document.getElementById('bird_sound');audio.src = '%s';audio.play();",
sound_url
))
} else {
showNotification("Bird sound not available",
type = "message", duration = 3)
}
})
})
})
# Handle name selection
observe({
req(rv_name_matching$birds)
birds_df <- rv_name_matching$birds
lapply(birds_df$taxonID, function(id) {
observeEvent(input[[paste0("name_", id)]], {
rv_name_matching$selected_name <- id
check_name_image_match()
})
})
})
# Handle image selection
observe({
req(rv_name_matching$birds)
birds_df <- rv_name_matching$birds
lapply(birds_df$taxonID, function(id) {
observeEvent(input[[paste0("image_", id)]], {
rv_name_matching$selected_image <- id
check_name_image_match()
})
})
})
# Check for matches in name-image game
check_name_image_match <- function() {
if (!is.null(rv_name_matching$selected_name) &&
!is.null(rv_name_matching$selected_image)) {
if (rv_name_matching$selected_name == rv_name_matching$selected_image) {
cat("\n>>> MATCH FOUND in name_matching at", as.character(Sys.time()), "\n")
# Match found
rv_name_matching$matches <- rv_name_matching$matches + 1
cat(">>> Updated matches to:", rv_name_matching$matches, "\n")
# Mark as matched
if (is.null(rv_name_matching$matched_ids)) rv_name_matching$matched_ids <- character(0)
rv_name_matching$matched_ids <- unique(c(rv_name_matching$matched_ids, rv_name_matching$selected_name))
# Get matched bird info
matched_id <- rv_name_matching$selected_name
matched_bird <- rv_name_matching$birds[rv_name_matching$birds$taxonID == matched_id, ]
# Dynamically add overlay to matched image (like Memory game)
overlay_html <- as.character(tagList(
# Name overlay (top-left)
div(
style="position:absolute;top:12px;left:12px;color:#fff;font-size:0.9em;background:rgba(0,123,255,0.95);padding:3px 8px;border-radius:4px;white-space:nowrap;font-weight:bold;",
matched_bird$scientificName
),
# Play button (bottom-left)
actionButton(
inputId = paste0("name_play_matched_sound_", matched_id),
label = tagList(icon("play"), "Play"),
class = "btn btn-sm btn-primary position-absolute",
style = "bottom:12px;left:12px;z-index:2;"
)
))
session$sendCustomMessage("addOverlay", list(
id = paste0("name_image_container_", matched_id),
html = overlay_html
))
# Disable and grey-out the matched name to avoid re-render flicker
session$sendCustomMessage('addClass', list(id = paste0('name_', matched_id), class = 'disabled-item'))
runjs(sprintf("$('#%s').prop('disabled', true);", paste0('name_', matched_id)))
# Set selected bird after a tiny delay to avoid stacking reflows with overlay injection
later::later(function() {
rv_name_matching$selected_bird <- matched_bird
}, delay = 0.05)
if (rv_name_matching$matches == rv_name_matching$total) {
session$sendCustomMessage("birdConfetti", list())
showNotification(
"ðŸŽ‰ Congratulations! You've matched all the birds!",
type = "message",
duration = 5
)
}
}
# Reset selections
rv_name_matching$selected_name <- NULL
rv_name_matching$selected_image <- NULL
}
}
# Display name matching score
output$name_matching_score <- renderText({
req(rv_name_matching$total)
sprintf("Matches: %d/%d", rv_name_matching$matches, rv_name_matching$total)
})
# Handle name-match play sound
observeEvent(input$name_match_play_sound, {
req(rv_name_matching$selected_bird)
sound_url <- get_sound_url(rv_name_matching$selected_bird$taxonID)
if(!is.null(sound_url)) {
runjs(sprintf("
var audio = document.getElementById('bird_sound');
audio.src = '%s';
audio.play();
", sound_url))
} else {
showNotification("Bird sound not available",
type = "message", duration = 3)
}
})
observeEvent(input$name_match_stop_sound, {
runjs("
var audio = document.getElementById('bird_sound');
if(audio){ audio.pause(); audio.currentTime = 0; }
")
})
# Sound-Image Matching Game Logic
rv_sound_matching <- reactiveValues(
birds = NULL,
selected_sound = NULL,
selected_image = NULL,
selected_bird = NULL,
matches = 0,
total = 0,
matched_ids = character(0),
order = NULL,
order_buttons = NULL
)
observeEvent(input$start_sound_matching, {
available_birds <- game_birds
n_birds <- min(6, nrow(available_birds))
idx <- sample(nrow(available_birds), n_birds)
rv_sound_matching$birds <- available_birds[idx, ]
rv_sound_matching$matches <- 0
rv_sound_matching$total <- n_birds
rv_sound_matching$selected_sound <- NULL
rv_sound_matching$selected_image <- NULL
rv_sound_matching$selected_bird <- NULL
rv_sound_matching$matched_ids <- character(0)
rv_sound_matching$order <- NULL  # Reset order to trigger new shuffle
rv_sound_matching$order_buttons <- NULL
})
output$sound_matching_buttons <- renderUI({
cat("\n>>> RE-RENDERING sound_matching_buttons at", as.character(Sys.time()), "\n")
birds_df <- req(rv_sound_matching$birds)
# Freeze order of buttons to avoid reordering/flicker
if (is.null(rv_sound_matching$order_buttons)) {
rv_sound_matching$order_buttons <- sample(nrow(birds_df))
}
order <- rv_sound_matching$order_buttons
div(class = "list-group",
lapply(order, function(i) {
actionButton(
inputId = paste0("sound_button_", birds_df$taxonID[i]),
label = tagList(icon("volume-up"), birds_df$scientificName[i]),
class = "list-group-item list-group-item-action"
)
})
)
}) %>% bindEvent(rv_sound_matching$birds, ignoreNULL = TRUE, ignoreInit = FALSE)
output$sound_matching_images <- renderUI({
cat("\n>>> RE-RENDERING sound_matching_images at", as.character(Sys.time()), "\n")
birds_df <- req(rv_sound_matching$birds)
# Freeze order like Name Matching
if (is.null(rv_sound_matching$order)) {
rv_sound_matching$order <- sample(nrow(birds_df))
}
order <- rv_sound_matching$order
div(class = "row",
lapply(order, function(i) {
id <- birds_df$taxonID[i]
# Don't check matched_ids here to avoid re-render on match
div(class = "col-md-4 mb-3 position-relative",
id = paste0("sound_image_container_", id),
actionButton(
inputId = paste0("sound_image_", id),
label = tags$img(
src = paste0("birdpics/", id, ".jpg"),
class = "square-img",
style = "max-width: 300px; max-height: 300px;"
),
class = "btn p-0"
)
)
})
)
}) %>% bindEvent(rv_sound_matching$birds, ignoreNULL = TRUE, ignoreInit = FALSE)
observe({
req(rv_sound_matching$birds)
birds_df <- rv_sound_matching$birds
lapply(birds_df$taxonID, function(id) {
observeEvent(input[[paste0("play_matched_sound_", id)]], {
sound_url <- get_sound_url(id)
if (!is.null(sound_url)) {
runjs(sprintf(
"var audio = document.getElementById('bird_sound');audio.src = '%s';audio.play();",
sound_url))
} else {
showNotification("Bird sound not available",
type = "message", duration = 3)
}
})
})
})
observe({
req(rv_sound_matching$birds)
birds_df <- rv_sound_matching$birds
lapply(birds_df$taxonID, function(id) {
observeEvent(input[[paste0("sound_button_", id)]], {
rv_sound_matching$selected_sound <- id
sound_url <- get_sound_url(id)
if (!is.null(sound_url)) {
runjs(sprintf("
var audio = document.getElementById('bird_sound');
audio.src = '%s';
audio.play();
", sound_url))
} else {
showNotification("Bird sound not available",
type = "message", duration = 3)
}
check_sound_image_match()
})
})
})
observe({
req(rv_sound_matching$birds)
birds_df <- rv_sound_matching$birds
lapply(birds_df$taxonID, function(id) {
observeEvent(input[[paste0("sound_image_", id)]], {
rv_sound_matching$selected_image <- id
check_sound_image_match()
})
})
})
check_sound_image_match <- function() {
if (!is.null(rv_sound_matching$selected_sound) && !is.null(rv_sound_matching$selected_image)) {
if (rv_sound_matching$selected_sound == rv_sound_matching$selected_image) {
rv_sound_matching$matches <- rv_sound_matching$matches + 1
if (is.null(rv_sound_matching$matched_ids)) rv_sound_matching$matched_ids <- character(0)
rv_sound_matching$matched_ids <- unique(c(rv_sound_matching$matched_ids, rv_sound_matching$selected_sound))
# Get matched bird info
matched_id <- rv_sound_matching$selected_sound
matched_bird <- rv_sound_matching$birds[rv_sound_matching$birds$taxonID == matched_id, ]
# Dynamically add overlay to matched image (like Memory and Name Matching)
overlay_html <- as.character(tagList(
# Name overlay (top-left)
div(
style="position:absolute;top:12px;left:12px;color:#fff;font-size:0.9em;background:rgba(0,123,255,0.95);padding:3px 8px;border-radius:4px;white-space:nowrap;font-weight:bold;",
matched_bird$scientificName
),
# Play button (bottom-left)
actionButton(
inputId = paste0("play_matched_sound_", matched_id),
label = tagList(icon("play"), "Play"),
class = "btn btn-sm btn-primary position-absolute",
style = "bottom:12px;left:12px;z-index:2;"
)
))
session$sendCustomMessage("addOverlay", list(
id = paste0("sound_image_container_", matched_id),
html = overlay_html
))
# Disable and grey-out the matched sound button so it can't be selected again
session$sendCustomMessage('addClass', list(id = paste0('sound_button_', matched_id), class = 'disabled-item'))
runjs(sprintf("$('#%s').prop('disabled', true);", paste0('sound_button_', matched_id)))
# Set selected bird after a tiny delay to avoid stacking reflows with overlay injection
later::later(function() {
rv_sound_matching$selected_bird <- matched_bird
}, delay = 0.05)
if (rv_sound_matching$matches == rv_sound_matching$total) {
session$sendCustomMessage("birdConfetti", list())
showNotification(
"ðŸŽ‰ Great! You've matched all the sounds!",
type = "message",
duration = 5
)
}
}
rv_sound_matching$selected_sound <- NULL
rv_sound_matching$selected_image <- NULL
}
}
output$sound_matching_score <- renderText({
req(rv_sound_matching$total)
sprintf("Matches: %d/%d", rv_sound_matching$matches, rv_sound_matching$total)
})
observeEvent(input$sound_match_play_sound, {
req(rv_sound_matching$selected_bird)
sound_url <- get_sound_url(rv_sound_matching$selected_bird$taxonID)
if (!is.null(sound_url)) {
runjs(sprintf("
var audio = document.getElementById('bird_sound');
audio.src = '%s';
audio.play();
", sound_url))
} else {
showNotification("Bird sound not available",
type = "message", duration = 3)
}
})
observeEvent(input$sound_match_stop_sound, {
runjs("
var audio = document.getElementById('bird_sound');
if(audio){ audio.pause(); audio.currentTime = 0; }
")
})
# Bird Browser
rv_browser <- reactiveValues(selected = NULL, search = "")
observe({ rv_browser$search <- tolower(ifelse(is.null(input$bird_search), "", input$bird_search)) })
output$bird_list <- renderUI({
req(exists("bird_df"))
birds <- bird_df %>% select(taxonID, scientificName) %>% distinct()
if (nchar(rv_browser$search) > 0) {
birds <- birds %>% filter(grepl(rv_browser$search, tolower(scientificName)))
}
div(class = "list-group",
lapply(seq_len(nrow(birds)), function(i){
id <- birds$taxonID[i]
sid <- paste0("browse_bird_", safe_id(id))
nm <- birds$scientificName[i]
actionLink(
inputId = sid,
label = tags$span(style = if(!is.null(rv_browser$selected) && rv_browser$selected$taxonID==id) "font-weight:bold; color:#007bff;" else "", nm),
class = "list-group-item list-group-item-action"
)
})
)
})
observe({
req(exists("bird_df"))
birds <- bird_df %>% select(taxonID, scientificName) %>% distinct()
lapply(seq_len(nrow(birds)), function(i){
id <- birds$taxonID[i]
sid <- paste0("browse_bird_", safe_id(id))
observeEvent(input[[sid]], {
rv_browser$selected <- birds[i, , drop = FALSE]
}, ignoreInit = TRUE)
})
})
# Clean only unwanted elements for Browser (keep hero image, keep columns)
clean_browser_content <- function(html_str) {
if (is.null(html_str) || is.na(html_str) || !nzchar(html_str)) return(html_str)
doc <- tryCatch(read_html(html_str), error = function(e) NULL)
if (is.null(doc)) return(html_str)
root <- xml2::xml_root(doc)
# remove nav tabs
suppressWarnings({
nav_tabs <- rvest::html_elements(root, "nav[role='tablist']")
if (length(nav_tabs) > 0) for (elem in nav_tabs) xml2::xml_remove(elem)
})
# remove add-to-my-species button
suppressWarnings({
add_btn <- rvest::html_elements(root, "app-add-to-my-species")
if (length(add_btn) > 0) for (elem in add_btn) xml2::xml_remove(elem)
})
as.character(root)
}
output$browser_bird_info <- renderUI({
req(rv_browser$selected)
html <- get_cached_info(rv_browser$selected$taxonID)
if (is.na(html) || is.null(html) || !nzchar(html)) {
url <- paste0("https://artfakta.se/taxa/", rv_browser$selected$taxonID, "/information")
return(tags$div(
class = "mt-2",
tags$div(class = "text-muted", "Live info (embedded from Artfakta):"),
tags$iframe(src = url, style = "width:100%;height:calc(100vh - 300px);border:1px solid #eee;border-radius:8px;")
))
}
# Show full content in Browser tab, but remove nav tabs and add-to-my-species button; keep main image
cleaned <- clean_browser_content(html)
title <- extract_artfakta_title(cleaned, fallback = rv_browser$selected$scientificName)
tagList(
h5(title),
HTML(format_artfakta_info(cleaned))
)
})
# Render Artfakta main-content for browser selected bird
output$browser_bird_info_html <- renderUI({
req(rv_browser$selected)
html <- get_cached_info(rv_browser$selected$taxonID)
if (is.na(html) || is.null(html)) return(NULL)
div(style = "max-height: 420px; overflow-y: auto; border-top: 1px solid #eee; margin-top: 10px; padding-top: 10px;",
HTML(html)
)
})
output$browser_bird_image <- renderUI({
req(rv_browser$selected)
tags$img(
src = paste0("birdpics/", rv_browser$selected$taxonID, ".jpg"),
style = "max-width:100%; height:auto; border-radius:8px;",
alt = rv_browser$selected$scientificName
)
})
observeEvent(input$browser_play_sound, {
req(rv_browser$selected)
sound_url <- get_sound_url(rv_browser$selected$taxonID)
if (!is.null(sound_url)) {
runjs(sprintf("
var audio = document.getElementById('bird_sound');
audio.src = '%s';
audio.play();
", sound_url))
} else {
showNotification("Bird sound not available",
type = "message", duration = 3)
}
})
observeEvent(input$browser_stop_sound, {
runjs("
var audio = document.getElementById('bird_sound');
if(audio){ audio.pause(); audio.currentTime = 0; }
")
})
output$browser_bird_timeline <- renderPlot({
req(rv_browser$selected)
bd <- bird_df %>% filter(taxonID == rv_browser$selected$taxonID)
if (nrow(bd) == 0) return(NULL)
if (!inherits(bd$eventDate, "Date")) suppressWarnings({ bd$eventDate <- as.Date(bd$eventDate) })
ggplot(bd, aes(x = eventDate)) +
geom_histogram(bins = 30, fill = "steelblue", color = "white") +
theme_minimal() +
labs(x = "Date", y = "Observations")
})
}
#setwd("04_BirdGame")
shiny::runApp()
